// ~/crm_app/backend/routes/services.js
const express = require('express');
const router = express.Router();
const db = require('../db');

// ===== Helpers =====
function toInt(v, def = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? n : def;
}
function toStr(v) {
  return (v ?? '').toString().trim();
}
function normStatus(s) {
  const x = toStr(s).toLowerCase();
  return x || 'scheduled';
}

/**
 * Normaliza una lÃ­nea de servicio admitiendo alias:
 * - description | service_name
 * - quantity | qty
 * - unit_price | price
 * Devuelve { ok, msg?, row? } (sin total; lo calcula la DB)
 */
function normalizeLine(line = {}, clientId) {
  const description = toStr(line.description) || toStr(line.service_name);
  const quantity    = toInt(line.quantity ?? line.qty, 1);
  const unit_price  = toInt(line.unit_price ?? line.price, 0);
  const status      = normStatus(line.status);

  if (!description) return { ok: false, msg: 'description/service_name is required' };

  return {
    ok: true,
    row: {
      client_id: toInt(clientId, 0),
      service_name: description,
      description,
      quantity,
      unit_price,
      status,
    }
  };
}

// =========================================
// GET /api/services
// q, client_id, status, page, limit
// =========================================
router.get('/', async (req, res) => {
  try {
    const { q = '', client_id = '', status = '', page = 1, limit = 10 } = req.query || {};
    const where = [];
    const params = [];
    let p = 1;

    if (q) {
      where.push(`(service_name ILIKE $${p} OR description ILIKE $${p})`);
      params.push(`%${q}%`); p++;
    }
    if (client_id) { where.push(`client_id = $${p}`); params.push(Number(client_id)); p++; }
    if (status)    { where.push(`status = $${p}`);    params.push(status); p++; }

    const whereSQL = where.length ? `WHERE ${where.join(' AND ')}` : '';
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.max(1, Math.min(100, Number(limit)));
    const offset = (pageNum - 1) * limitNum;

    const listSQL = `
      SELECT id, client_id, service_name, description, quantity, unit_price, total, status, created_at
      FROM services
      ${whereSQL}
      ORDER BY id DESC
      LIMIT ${limitNum} OFFSET ${offset}
    `;
    const countSQL = `SELECT COUNT(*)::int AS n FROM services ${whereSQL}`;

    const [listRes, countRes] = await Promise.all([
      db.query(listSQL, params),
      db.query(countSQL, params),
    ]);

    res.json({
      page: pageNum,
      total: countRes.rows[0]?.n ?? 0,
      items: listRes.rows || [],
    });
  } catch (err) {
    console.error('GET /services error:', err);
    res.status(500).json({ error: 'Internal error listing services' });
  }
});

// =========================================
// GET /api/services/:id
// =========================================
router.get('/:id', async (req, res) => {
  try {
    const id = Number(req.params.id);
    const r = await db.query(
      `SELECT id, client_id, service_name, description, quantity, unit_price, total, status, created_at
       FROM services WHERE id = $1`,
      [id]
    );
    if (!r.rows.length) return res.status(404).json({ error: 'Not found' });
    res.json(r.rows[0]);
  } catch (err) {
    console.error('GET /services/:id error:', err);
    res.status(500).json({ error: 'Internal error loading service' });
  }
});

// =========================================
// POST /api/services
// Single:
//   { client_id, description|service_name, quantity?, unit_price?, status? }
// Batch:
//   { client_id, lines: [ { description|service_name, quantity|qty?, unit_price|price?, status? }, ... ] }
// * No insertamos "total": lo calcula la DB (GENERATED/trigger)
// =========================================
router.post('/', async (req, res) => {
  try {
    const body = req.body || {};
    const clientId = toInt(body.client_id ?? body.clientId, 0);
    if (!clientId) return res.status(400).json({ error: 'client_id is required' });

    // Batch
    if (Array.isArray(body.lines) && body.lines.length) {
      const rows = [];
      for (const ln of body.lines) {
        const norm = normalizeLine(ln, clientId);
        if (!norm.ok) return res.status(400).json({ error: `Invalid line: ${norm.msg}` });
        rows.push(norm.row);
      }

      const cols = ['client_id','service_name','description','quantity','unit_price','status'];
      const values = [];
      const params = [];
      let p = 1;
      for (const r of rows) {
        params.push(r.client_id, r.service_name, r.description, r.quantity, r.unit_price, r.status);
        values.push(`($${p}, $${p+1}, $${p+2}, $${p+3}, $${p+4}, $${p+5})`);
        p += 6;
      }

      const sql = `
        INSERT INTO services (${cols.join(', ')})
        VALUES ${values.join(', ')}
        RETURNING id, client_id, service_name, description, quantity, unit_price, total, status, created_at
      `;
      const ins = await db.query(sql, params);
      return res.status(201).json({ items: ins.rows });
    }

    // Single
    const norm = normalizeLine(body, clientId);
    if (!norm.ok) return res.status(400).json({ error: norm.msg || 'Invalid payload' });
    const R = norm.row;

    const ins = await db.query(
      `INSERT INTO services (client_id, service_name, description, quantity, unit_price, status)
       VALUES ($1,$2,$3,$4,$5,$6)
       RETURNING id, client_id, service_name, description, quantity, unit_price, total, status, created_at`,
      [R.client_id, R.service_name, R.description, R.quantity, R.unit_price, R.status]
    );
    res.status(201).json(ins.rows[0]);
  } catch (err) {
    console.error('POST /services error:', err);
    res.status(500).json({ error: 'Internal error creating service(s)' });
  }
});

// =========================================
// PUT /api/services/:id
// * No tocamos "total": que lo recalcule la DB
// =========================================
router.put('/:id', async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { client_id, service_name, description, quantity, unit_price, status } = req.body || {};

    const sets = [];
    const params = [];
    let p = 1;

    if (client_id !== undefined)  { sets.push(`client_id = $${p++}`);   params.push(client_id); }
    if (service_name !== undefined){ sets.push(`service_name = $${p++}`); params.push(toStr(service_name)); }
    if (description !== undefined){ sets.push(`description = $${p++}`); params.push(toStr(description)); }
    if (quantity !== undefined)   { sets.push(`quantity = $${p++}`);    params.push(toInt(quantity, 1)); }
    if (unit_price !== undefined) { sets.push(`unit_price = $${p++}`);  params.push(toInt(unit_price, 0)); }
    if (status !== undefined)     { sets.push(`status = $${p++}`);      params.push(normStatus(status)); }

    if (!sets.length) return res.status(400).json({ error: 'No fields to update' });

    const sql = `
      UPDATE services
      SET ${sets.join(', ')}
      WHERE id = $${p}
      RETURNING id, client_id, service_name, description, quantity, unit_price, total, status, created_at
    `;
    params.push(id);
    const r = await db.query(sql, params);
    if (!r.rows.length) return res.status(404).json({ error: 'Not found' });
    res.json(r.rows[0]);
  } catch (err) {
    console.error('PUT /services/:id error:', err);
    res.status(500).json({ error: 'Internal error updating service' });
  }
});

// =========================================
router.delete('/:id', async (req, res) => {
  try {
    const id = Number(req.params.id);
    const r = await db.query('DELETE FROM services WHERE id = $1 RETURNING id', [id]);
    if (!r.rows.length) return res.status(404).json({ error: 'Not found' });
    res.json({ ok: true, id });
  } catch (err) {
    console.error('DELETE /services/:id error:', err);
    res.status(500).json({ error: 'Internal error deleting service' });
  }
});

module.exports = router;
