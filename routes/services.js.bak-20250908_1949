// routes/services.js
const express = require('express');
const router = express.Router();
const db = require('../db'); // Debe exponer db.query(text, params)

function toInt(v, d = 0) {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : d;
}

function cleanSort(sort) {
  // Permitir solo columnas whitelisted
  const allow = {
    id: 's.id',
    created_at: 's.created_at',
    total: 's.total',
    unit_price: 's.unit_price',
    quantity: 's.quantity'
  };
  let dir = 'DESC';
  let key = sort || '-created_at';
  if (key.startsWith('-')) {
    key = key.slice(1);
    dir = 'DESC';
  } else if (key.startsWith('+')) {
    key = key.slice(1);
    dir = 'ASC';
  } else {
    dir = 'ASC';
  }
  const col = allow[key] || 's.created_at';
  return `${col} ${dir}`;
}

// GET /api/services  (listado con filtros y paginación)
// Soporta: q, status, client_id, page, limit, sort
router.get('/', async (req, res) => {
  try {
    const q = (req.query.q || '').trim();
    const status = (req.query.status || '').trim(); // 'open','in_progress','completed','cancelled' o vacío
    const clientId = req.query.client_id ? toInt(req.query.client_id, null) : null;
    const page = Math.max(1, toInt(req.query.page, 1));
    const limit = Math.min(100, Math.max(1, toInt(req.query.limit, 10)));
    const offset = (page - 1) * limit;
    const orderBy = cleanSort(req.query.sort);

    const where = [];
    const params = [];

    if (q) {
      params.push(`%${q}%`);
      const p1 = params.length;
      params.push(`%${q}%`);
      const p2 = params.length;
      where.push(`(s.service_name ILIKE $${p1} OR s.description ILIKE $${p2})`);
    }
    if (clientId) {
      params.push(clientId);
      where.push(`s.client_id = $${params.length}`);
    }
    if (status && status !== 'all') {
      params.push(status);
      where.push(`s.status = $${params.length}`);
    }

    const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

    const countSql = `SELECT COUNT(*)::int AS c FROM services s ${whereSql}`;
    const { rows: countRows } = await db.query(countSql, params);
    const total = countRows[0]?.c || 0;
    const totalPages = Math.max(1, Math.ceil(total / limit));

    const listSql = `
      SELECT s.*
      FROM services s
      ${whereSql}
      ORDER BY ${orderBy}
      LIMIT $${params.length + 1}
      OFFSET $${params.length + 2}
    `;
    const { rows: items } = await db.query(listSql, [...params, limit, offset]);

    res.json({
      page,
      limit,
      total,
      totalPages,
      hasPrev: page > 1,
      hasNext: page < totalPages,
      items,
    });
  } catch (err) {
    console.error('GET /services error:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// GET /api/services/:id (detalle)
router.get('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, null);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const { rows } = await db.query('SELECT * FROM services WHERE id = $1', [id]);
    if (!rows.length) return res.status(404).json({ error: 'Not found' });
    res.json(rows[0]);
  } catch (err) {
    console.error('GET /services/:id error:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// POST /api/services (crear)
router.post('/', async (req, res) => {
  try {
    let {
      client_id,
      service_name,
      description = '',
      quantity = 1,
      unit_price = 0,
      status = 'open',
    } = req.body || {};

    client_id = toInt(client_id, null);
    quantity = Number(quantity);
    unit_price = Number(unit_price);
    if (!client_id) return res.status(400).json({ error: 'client_id is required' });
    if (!service_name || !service_name.trim()) return res.status(400).json({ error: 'service_name is required' });

    const total = Number((quantity * unit_price).toFixed(2));

    const insertSql = `
      INSERT INTO services
        (client_id, service_name, description, quantity, unit_price, total, status)
      VALUES
        ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *;
    `;
    const { rows } = await db.query(insertSql, [
      client_id, service_name.trim(), description, quantity, unit_price, total, status
    ]);
    res.status(201).json(rows[0]);
  } catch (err) {
    console.error('POST /services error:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// PUT /api/services/:id (actualizar)
router.put('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, null);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    // Usamos COALESCE para actualizar parcialmente y recalcular total
    const {
      client_id = null,
      service_name = null,
      description = null,
      quantity = null,
      unit_price = null,
      status = null,
    } = req.body || {};

    const sql = `
      UPDATE services s
      SET
        client_id   = COALESCE($1, s.client_id),
        service_name= COALESCE($2, s.service_name),
        description = COALESCE($3, s.description),
        quantity    = COALESCE($4, s.quantity),
        unit_price  = COALESCE($5, s.unit_price),
        status      = COALESCE($6, s.status),
        total       = (COALESCE($4, s.quantity) * COALESCE($5, s.unit_price))
      WHERE s.id = $7
      RETURNING *;
    `;
    const { rows } = await db.query(sql, [
      client_id, service_name, description,
      quantity, unit_price, status, id
    ]);
    if (!rows.length) return res.status(404).json({ error: 'Not found' });
    res.json(rows[0]);
  } catch (err) {
    console.error('PUT /services/:id error:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// DELETE /api/services/:id
router.delete('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, null);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const { rowCount } = await db.query('DELETE FROM services WHERE id = $1', [id]);
    if (!rowCount) return res.status(404).json({ error: 'Not found' });
    res.json({ success: true });
  } catch (err) {
    console.error('DELETE /services/:id error:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

module.exports = router;

