// ---------- CREATE: guarda invoice + líneas (items o service_ids) ----------
router.post('/create', async (req, res) => {
  let client; // << declarar fuera
  try {
    const { client_id, currency='USD', discount=0, tax=0, items=[], service_ids=[] } = req.body || {};
    const clientId = Number(client_id);
    if (!clientId) return res.status(400).json({ error: 'client_id is required' });

    client = await db.connect();              // << ahora DENTRO del try
    const lines = [];

    // services por ID
    if (Array.isArray(service_ids) && service_ids.length) {
      const q = `
        SELECT id, service_name, description, quantity, unit_price
        FROM services
        WHERE id = ANY($1::int[]) AND client_id = $2
      `;
      const r = await client.query(q, [service_ids.map(Number), clientId]);
      for (const s of r.rows) {
        lines.push({
          service_id: s.id,
          description: s.description || s.service_name || `WO #${s.id}`,
          quantity: Number(s.quantity) || 1,
          unit_price: Number(s.unit_price) || 0
        });
      }
    }

    // items ad-hoc
    if (Array.isArray(items) && items.length) {
      for (const raw of items) {
        const n = normItem(raw);
        if (!n.ok) return res.status(400).json({ error: n.msg });
        lines.push({
          service_id: raw.service_id ? Number(raw.service_id) : null,
          description: n.description,
          quantity: n.quantity,
          unit_price: n.unit_price
        });
      }
    }

    if (!lines.length) return res.status(400).json({ error: 'No items or service_ids provided' });

    const subtotal  = lines.reduce((a, l) => a + (l.quantity * l.unit_price), 0);
    const _discount = toNum(discount);
    const _tax      = toNum(tax);
    const total     = subtotal - _discount + _tax;

    await client.query('BEGIN');

    const invoice_no = await getNextInvoiceNo(client);

    const invIns = `
      INSERT INTO invoices (invoice_no, client_id, currency, subtotal, discount, tax, total, status, provider)
      VALUES ($1,$2,$3,$4,$5,$6,$7,'issued','invoice-generator')
      RETURNING id, invoice_no, client_id, currency, subtotal, discount, tax, total, status, created_at
    `;
    const invRes = await client.query(invIns, [
      invoice_no, clientId, currency, subtotal, _discount, _tax, total
    ]);
    const invoice = invRes.rows[0];

    // líneas
    const cols = ['invoice_id','service_id','description','quantity','unit_price'];
    const params = [];
    const values = [];
    let p = 1;
    for (const l of lines) {
      values.push(`($${p++}, $${p++}, $${p++}, $${p++}, $${p++})`);
      params.push(invoice.id, l.service_id ?? null, l.description, l.quantity, l.unit_price);
    }
    const lineSQL = `
      INSERT INTO invoice_lines (${cols.join(',')})
      VALUES ${values.join(',')}
      RETURNING id, invoice_id, service_id, description, quantity, unit_price, line_total
    `;
    const lineRes = await client.query(lineSQL, params);

    await client.query('COMMIT');
    return res.status(201).json({ ...invoice, lines: lineRes.rows });
  } catch (err) {
    // rollback si había transacción abierta
    try { if (client) await client.query('ROLLBACK'); } catch {}
    console.error('POST /invoices/create ERROR:', err.stack || err);
    return res.status(500).json({ error: 'Internal error creating invoice' });
  } finally {
    try { if (client) client.release(); } catch {}
  }
});
