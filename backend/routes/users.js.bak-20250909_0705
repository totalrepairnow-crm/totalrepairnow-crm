// ~/crm_app/backend/routes/users.js
const express = require('express');
const router = express.Router();
const db = require('../db');
const bcrypt = require('bcryptjs');

/** Helpers */
const ALLOWED_ROLES = ['admin', 'client', 'tech'];

const toInt = (v, d = 0) => {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : d;
};

const isValidRole = (r) => ALLOWED_ROLES.includes(String(r || '').toLowerCase());

const mapUser = (u) => ({
  id: u.id,
  name: u.name || null,
  email: u.email,
  phone: u.phone || null,
  role: u.role,
  created_at: u.created_at,
});

/** Detectar si la tabla users usa password_hash o password */
let PASSWORD_COL_CACHE = null;
async function getPasswordColumn() {
  if (PASSWORD_COL_CACHE) return PASSWORD_COL_CACHE;
  const q = `
    SELECT column_name
    FROM information_schema.columns
    WHERE table_name='users' AND column_name IN ('password_hash','password')
    ORDER BY CASE column_name WHEN 'password_hash' THEN 0 ELSE 1 END
    LIMIT 1
  `;
  const { rows } = await db.query(q);
  PASSWORD_COL_CACHE = rows[0]?.column_name || null;
  return PASSWORD_COL_CACHE;
}

/** GET /api/users
 *  Soporta: ?q=&role=&page=&limit=
 *  Respuesta: { page, limit, total, totalPages, hasPrev, hasNext, items:[...] }
 */
router.get('/', async (req, res) => {
  try {
    const q = (req.query.q || '').trim();
    const role = (req.query.role || '').trim().toLowerCase();
    const page = Math.max(1, toInt(req.query.page, 1));
    const limit = Math.min(100, Math.max(1, toInt(req.query.limit, 10)));
    const offset = (page - 1) * limit;

    const where = [];
    const params = [];

    if (q) {
      params.push(`%${q}%`);
      where.push(`(email ILIKE $${params.length} OR name ILIKE $${params.length} OR phone ILIKE $${params.length})`);
    }

    if (role) {
      params.push(role);
      where.push(`LOWER(role) = $${params.length}`);
    }

    const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

    const countSql = `SELECT COUNT(*)::int AS c FROM users ${whereSql}`;
    const total = (await db.query(countSql, params)).rows[0].c;

    const listSql = `
      SELECT id, name, email, phone, role, created_at
      FROM users
      ${whereSql}
      ORDER BY created_at DESC
      LIMIT $${params.length + 1} OFFSET $${params.length + 2}
    `;
    const listParams = params.concat([limit, offset]);
    const r = await db.query(listSql, listParams);

    const totalPages = Math.max(1, Math.ceil(total / limit));
    res.json({
      page,
      limit,
      total,
      totalPages,
      hasPrev: page > 1,
      hasNext: page < totalPages,
      items: r.rows.map(mapUser),
    });
  } catch (e) {
    console.error('GET /users error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** GET /api/users/:id */
router.get('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const r = await db.query(
      `SELECT id, name, email, phone, role, created_at FROM users WHERE id = $1`,
      [id]
    );
    if (!r.rows.length) return res.status(404).json({ error: 'Not found' });
    res.json(mapUser(r.rows[0]));
  } catch (e) {
    console.error('GET /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** POST /api/users
 * body: { name, email, password?, phone?, role }
 */
router.post('/', async (req, res) => {
  try {
    const { name, email, password, phone, role } = req.body || {};

    if (!email || !role) {
      return res.status(400).json({ error: 'email and role are required' });
    }
    if (!isValidRole(role)) {
      return res.status(400).json({ error: `Invalid role. Allowed: ${ALLOWED_ROLES.join(', ')}` });
    }

    const pwdCol = await getPasswordColumn();
    let pwdHash = null;

    if (password && pwdCol) {
      // hash con bcryptjs
      const salt = await bcrypt.genSalt(10);
      pwdHash = await bcrypt.hash(String(password), salt);
    }

    const cols = ['email', 'role'];
    const vals = [email, role.toLowerCase()];
    const placeholders = ['$1', '$2'];

    if (name !== undefined) { cols.push('name'); vals.push(name); placeholders.push(`$${vals.length}`); }
    if (phone !== undefined) { cols.push('phone'); vals.push(phone); placeholders.push(`$${vals.length}`); }
    if (pwdCol && pwdHash) { cols.push(pwdCol); vals.push(pwdHash); placeholders.push(`$${vals.length}`); }

    const sql = `
      INSERT INTO users (${cols.join(', ')})
      VALUES (${placeholders.join(', ')})
      RETURNING id, name, email, phone, role, created_at
    `;
    const r = await db.query(sql, vals);

    res.status(201).json(mapUser(r.rows[0]));
  } catch (e) {
    if (e && e.code === '23505') { // unique_violation
      return res.status(409).json({ error: 'Email already exists' });
    }
    console.error('POST /users error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** PUT /api/users/:id
 * body: { name?, email?, phone?, role?, password? }
 */
router.put('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const { name, email, phone, role, password } = req.body || {};
    const sets = [];
    const params = [];

    const push = (frag, val) => { params.push(val); sets.push(`${frag} = $${params.length}`); };

    if (name !== undefined) push('name', name);
    if (email !== undefined) push('email', email);
    if (phone !== undefined) push('phone', phone);
    if (role !== undefined) {
      if (!isValidRole(role)) return res.status(400).json({ error: `Invalid role. Allowed: ${ALLOWED_ROLES.join(', ')}` });
      push('role', role.toLowerCase());
    }
    if (password !== undefined) {
      const pwdCol = await getPasswordColumn();
      if (pwdCol) {
        const salt = await bcrypt.genSalt(10);
        const hash = await bcrypt.hash(String(password), salt);
        push(pwdCol, hash);
      }
    }

    if (!sets.length) return res.status(400).json({ error: 'No fields to update' });

    params.push(id);
    const sql = `
      UPDATE users SET ${sets.join(', ')}, updated_at = NOW()
      WHERE id = $${params.length}
      RETURNING id, name, email, phone, role, created_at
    `;
    const r = await db.query(sql, params);
    if (!r.rows.length) return res.status(404).json({ error: 'Not found' });

    res.json(mapUser(r.rows[0]));
  } catch (e) {
    if (e && e.code === '23505') {
      return res.status(409).json({ error: 'Email already exists' });
    }
    console.error('PUT /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** DELETE /api/users/:id */
router.delete('/:id', async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    // (opcional) evitar que se borre el Ãºltimo admin
    // const admins = await db.query(`SELECT COUNT(*)::int AS c FROM users WHERE LOWER(role)='admin'`);
    // if (admins.rows[0].c <= 1) return res.status(400).json({ error: 'Cannot delete the last admin' });

    const r = await db.query(`DELETE FROM users WHERE id = $1`, [id]);
    if (r.rowCount === 0) return res.status(404).json({ error: 'Not found' });
    res.json({ success: true });
  } catch (e) {
    console.error('DELETE /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

module.exports = router;
