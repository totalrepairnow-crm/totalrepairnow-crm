// routes/users.js — versión “compat” sin || en SQL
const express = require('express');
const bcrypt = require('bcrypt');
const router = express.Router();
const db = require('../db');

// Middlewares (si no existen, no-op)
let requireAuth = (_req, _res, next) => next();
let requireAdmin = (_req, _res, next) => next();
try {
  const roles = require('../middleware/roles');
  requireAuth = roles.requireAuth || requireAuth;
  requireAdmin = roles.requireAdmin || requireAdmin;
} catch (_e) {}

const ALLOWED_ROLES = new Set(['admin', 'tech', 'client']);
const toInt = (v, d = 0) => {
  const n = Number.parseInt(v, 10);
  return Number.isFinite(n) && n > 0 ? n : d;
};

const mapUser = (row) => {
  const first = (row.first_name || '').trim();
  const last  = (row.last_name  || '').trim();
  const name  = (first || last) ? `${first}${first && last ? ' ' : ''}${last}` : null;
  return {
    id: row.id,
    first_name: first || null,
    last_name:  last  || null,
    name,
    email: row.email,
    phone: row.phone || null,
    role: row.role || 'client',
    created_at: row.created_at
  };
};

/** GET /api/users?q=&role=&page=&limit= */
router.get('/', requireAuth, async (req, res) => {
  try {
    const { q = '', role = '', page = '1', limit = '10' } = req.query || {};
    const p = Math.max(1, toInt(page, 1));
    const l = Math.min(100, Math.max(1, toInt(limit, 10)));
    const ofs = (p - 1) * l;

    const where = [];
    const args = [];

    if (q && String(q).trim()) {
      args.push(`%${String(q).trim()}%`);
      const idx = args.length;
      where.push(`(
        (first_name IS NOT NULL AND first_name ILIKE $${idx})
        OR (last_name IS NOT NULL AND last_name ILIKE $${idx})
        OR email ILIKE $${idx}
        OR (phone IS NOT NULL AND phone ILIKE $${idx})
      )`);
    }
    if (role && String(role).trim()) {
      args.push(String(role).trim());
      where.push(`role = $${args.length}`);
    }

    const whereSQL = where.length ? `WHERE ${where.join(' AND ')}` : '';

    const { rows: crows } = await db.query(
      `SELECT COUNT(*)::int AS cnt FROM users ${whereSQL}`,
      args
    );
    const total = crows[0]?.cnt || 0;

    args.push(l, ofs);
    const { rows } = await db.query(
      `SELECT id, first_name, last_name, email, phone, role, created_at
       FROM users
       ${whereSQL}
       ORDER BY id DESC
       LIMIT $${args.length - 1} OFFSET $${args.length}`,
      args
    );

    const items = rows.map(mapUser);
    const totalPages = Math.max(1, Math.ceil(total / l));
    res.json({
      items,
      page: p,
      limit: l,
      total,
      totalPages,
      hasPrev: p > 1,
      hasNext: p < totalPages
    });
  } catch (e) {
    console.error('GET /users error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** GET /api/users/:id */
router.get('/:id', requireAuth, async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const { rows } = await db.query(
      `SELECT id, first_name, last_name, email, phone, role, created_at
       FROM users WHERE id = $1 LIMIT 1`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: 'Not found' });

    res.json(mapUser(rows[0]));
  } catch (e) {
    console.error('GET /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** POST /api/users */
router.post('/', requireAdmin, async (req, res) => {
  try {
    const {
      first_name = '',
      last_name  = '',
      email,
      phone = '',
      role  = 'client',
      password
    } = req.body || {};

    if (!email || !password) {
      return res.status(400).json({ error: 'Missing email or password' });
    }
    if (!ALLOWED_ROLES.has(role)) {
      return res.status(400).json({ error: 'Invalid role' });
    }

    const hash = await bcrypt.hash(String(password), 10);

    const { rows } = await db.query(
      `INSERT INTO users (first_name, last_name, email, phone, role, password_hash, created_at)
       VALUES ($1,$2,$3,$4,$5,$6,NOW())
       RETURNING id, first_name, last_name, email, phone, role, created_at`,
      [first_name || null, last_name || null, email.trim(), phone || null, role, hash]
    );

    res.status(201).json(mapUser(rows[0]));
  } catch (e) {
    if (e?.code === '23505') {
      return res.status(409).json({ error: 'Email already in use' });
    }
    console.error('POST /users error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** PUT /api/users/:id */
router.put('/:id', requireAdmin, async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const { first_name, last_name, email, phone, role, password } = req.body || {};
    const sets = [];
    const args = [];
    const push = (frag, val) => { args.push(val); sets.push(`${frag} = $${args.length}`); };

    if (first_name !== undefined) push('first_name', first_name || null);
    if (last_name  !== undefined) push('last_name',  last_name  || null);
    if (email      !== undefined) push('email',      email);
    if (phone      !== undefined) push('phone',      phone || null);
    if (role       !== undefined) {
      if (!ALLOWED_ROLES.has(role)) return res.status(400).json({ error: 'Invalid role' });
      push('role', role);
    }
    if (password !== undefined && password !== '') {
      const hash = await bcrypt.hash(String(password), 10);
      push('password_hash', hash);
    }

    if (!sets.length) return res.status(400).json({ error: 'No fields to update' });

    args.push(id);
    const { rows } = await db.query(
      `UPDATE users SET ${sets.join(', ')}, updated_at = NOW()
       WHERE id = $${args.length}
       RETURNING id, first_name, last_name, email, phone, role, created_at`,
      args
    );
    if (!rows.length) return res.status(404).json({ error: 'Not found' });

    res.json(mapUser(rows[0]));
  } catch (e) {
    if (e?.code === '23505') {
      return res.status(409).json({ error: 'Email already in use' });
    }
    console.error('PUT /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

/** DELETE /api/users/:id */
router.delete('/:id', requireAdmin, async (req, res) => {
  try {
    const id = toInt(req.params.id, 0);
    if (!id) return res.status(400).json({ error: 'Invalid id' });

    const r = await db.query(`DELETE FROM users WHERE id = $1`, [id]);
    if (r.rowCount === 0) return res.status(404).json({ error: 'Not found' });

    res.json({ success: true });
  } catch (e) {
    console.error('DELETE /users/:id error:', e);
    res.status(500).json({ error: 'Internal error' });
  }
});

module.exports = router;
