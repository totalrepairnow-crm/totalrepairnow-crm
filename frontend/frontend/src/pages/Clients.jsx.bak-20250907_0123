// ~/crm_app/frontend_v2/crm-frontend-v2/src/pages/Clients.jsx
import { useEffect, useMemo, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import Spinner from '../components/Spinner';
import { getClients } from '../lib/api';

// pequeño hook para "debounce"
function useDebouncedValue(value, delay = 300) {
  const [debounced, setDebounced] = useState(value);
  useEffect(() => {
    const id = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(id);
  }, [value, delay]);
  return debounced;
}

export default function Clients() {
  const nav = useNavigate();

  const [q, setQ] = useState('');
  const dq = useDebouncedValue(q, 300);

  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(10);

  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(1);

  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState('');

  // reset a página 1 cuando cambia la búsqueda (debounced)
  useEffect(() => { setPage(1); }, [dq]);

  useEffect(() => {
    let alive = true;
    async function load() {
      setLoading(true);
      setErr('');
      try {
        const data = await getClients({ q: dq, page, limit });
        // soporta backend viejo que devolvía array plano
        if (Array.isArray(data)) {
          if (!alive) return;
          setItems(data);
          setTotal(data.length);
          setTotalPages(1);
        } else {
          if (!alive) return;
          setItems(data.items || []);
          setTotal(data.total ?? (data.items?.length || 0));
          setTotalPages(data.totalPages || 1);
        }
      } catch (e) {
        if (!alive) return;
        setErr(e.message || 'Failed to load');
      } finally {
        if (alive) setLoading(false);
      }
    }
    load();
    return () => { alive = false; };
  }, [dq, page, limit]);

  const showingFrom = useMemo(() => (total ? (page - 1) * limit + 1 : 0), [page, limit, total]);
  const showingTo   = useMemo(() => Math.min(page * limit, total), [page, limit, total]);

  return (
    <div>
      <div className="toolbar">
        <h1>Clients</h1>
        <div className="toolbar-actions" style={{gap:12, display:'flex', alignItems:'center'}}>
          <input
            className="input"
            placeholder="Search..."
            value={q}
            onChange={e => setQ(e.target.value)}
            style={{minWidth:220}}
          />
          <select className="input" value={limit} onChange={e => setLimit(Number(e.target.value))}>
            {[10,20,50,100].map(n => <option key={n} value={n}>{n}/page</option>)}
          </select>
          <button className="btn btn-primary" onClick={() => nav('/clients/new')}>
            New Client
          </button>
        </div>
      </div>

      {err && <div className="alert error">{err}</div>}

      {loading && <Spinner />}

      <div className="table-wrap">
        <table className="table">
          <thead>
            <tr>
              <th>Name</th><th>Email</th><th>Phone</th><th>Created</th>
            </tr>
          </thead>
          <tbody>
            {!loading && items.map(c => {
              const name = [c.first_name, c.last_name].filter(Boolean).join(' ') || '(no name)';
              return (
                <tr key={c.id}>
                  <td><Link to={`/clients/${c.id}`}>{name}</Link></td>
                  <td>{c.email || '-'}</td>
                  <td>{c.phone || '-'}</td>
                  <td>{c.created_at ? new Date(c.created_at).toLocaleString() : '-'}</td>
                </tr>
              );
            })}
            {!loading && !items.length && (
              <tr><td colSpan={4} style={{textAlign:'center', color:'#64748b'}}>No results</td></tr>
            )}
          </tbody>
        </table>
      </div>

      <div className="pager" style={{display:'flex', alignItems:'center', gap:12, marginTop:16}}>
        <button
          className="btn"
          disabled={loading || page <= 1}
          onClick={() => setPage(p => Math.max(1, p - 1))}
        >‹ Prev</button>

        <span style={{color:'#64748b'}}>
          Page {page} of {totalPages} · Showing {showingFrom || 0}-{showingTo || 0} of {total}
        </span>

        <button
          className="btn"
          disabled={loading || page >= totalPages}
          onClick={() => setPage(p => Math.min(totalPages, p + 1))}
        >Next ›</button>
      </div>
    </div>
  );
}

